// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"context"
	"github.com/m-mizutani/gollam"
	"sync"
)

// LLMClientMock is a mock implementation of gollam.LLMClient.
//
//	func TestSomethingThatUsesLLMClient(t *testing.T) {
//
//		// make and configure a mocked gollam.LLMClient
//		mockedLLMClient := &LLMClientMock{
//			NewSessionFunc: func(ctx context.Context, options ...gollam.SessionOption) (gollam.Session, error) {
//				panic("mock out the NewSession method")
//			},
//		}
//
//		// use mockedLLMClient in code that requires gollam.LLMClient
//		// and then make assertions.
//
//	}
type LLMClientMock struct {
	// NewSessionFunc mocks the NewSession method.
	NewSessionFunc func(ctx context.Context, options ...gollam.SessionOption) (gollam.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// NewSession holds details about calls to the NewSession method.
		NewSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Options is the options argument value.
			Options []gollam.SessionOption
		}
	}
	lockNewSession sync.RWMutex
}

// NewSession calls NewSessionFunc.
func (mock *LLMClientMock) NewSession(ctx context.Context, options ...gollam.SessionOption) (gollam.Session, error) {
	callInfo := struct {
		Ctx     context.Context
		Options []gollam.SessionOption
	}{
		Ctx:     ctx,
		Options: options,
	}
	mock.lockNewSession.Lock()
	mock.calls.NewSession = append(mock.calls.NewSession, callInfo)
	mock.lockNewSession.Unlock()
	if mock.NewSessionFunc == nil {
		var (
			sessionOut gollam.Session
			errOut     error
		)
		return sessionOut, errOut
	}
	return mock.NewSessionFunc(ctx, options...)
}

// NewSessionCalls gets all the calls that were made to NewSession.
// Check the length with:
//
//	len(mockedLLMClient.NewSessionCalls())
func (mock *LLMClientMock) NewSessionCalls() []struct {
	Ctx     context.Context
	Options []gollam.SessionOption
} {
	var calls []struct {
		Ctx     context.Context
		Options []gollam.SessionOption
	}
	mock.lockNewSession.RLock()
	calls = mock.calls.NewSession
	mock.lockNewSession.RUnlock()
	return calls
}

// SessionMock is a mock implementation of gollam.Session.
//
//	func TestSomethingThatUsesSession(t *testing.T) {
//
//		// make and configure a mocked gollam.Session
//		mockedSession := &SessionMock{
//			GenerateContentFunc: func(ctx context.Context, input ...gollam.Input) (*gollam.Response, error) {
//				panic("mock out the GenerateContent method")
//			},
//			GenerateStreamFunc: func(ctx context.Context, input ...gollam.Input) (<-chan *gollam.Response, error) {
//				panic("mock out the GenerateStream method")
//			},
//			HistoryFunc: func() *gollam.History {
//				panic("mock out the History method")
//			},
//		}
//
//		// use mockedSession in code that requires gollam.Session
//		// and then make assertions.
//
//	}
type SessionMock struct {
	// GenerateContentFunc mocks the GenerateContent method.
	GenerateContentFunc func(ctx context.Context, input ...gollam.Input) (*gollam.Response, error)

	// GenerateStreamFunc mocks the GenerateStream method.
	GenerateStreamFunc func(ctx context.Context, input ...gollam.Input) (<-chan *gollam.Response, error)

	// HistoryFunc mocks the History method.
	HistoryFunc func() *gollam.History

	// calls tracks calls to the methods.
	calls struct {
		// GenerateContent holds details about calls to the GenerateContent method.
		GenerateContent []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollam.Input
		}
		// GenerateStream holds details about calls to the GenerateStream method.
		GenerateStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Input is the input argument value.
			Input []gollam.Input
		}
		// History holds details about calls to the History method.
		History []struct {
		}
	}
	lockGenerateContent sync.RWMutex
	lockGenerateStream  sync.RWMutex
	lockHistory         sync.RWMutex
}

// GenerateContent calls GenerateContentFunc.
func (mock *SessionMock) GenerateContent(ctx context.Context, input ...gollam.Input) (*gollam.Response, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollam.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGenerateContent.Lock()
	mock.calls.GenerateContent = append(mock.calls.GenerateContent, callInfo)
	mock.lockGenerateContent.Unlock()
	if mock.GenerateContentFunc == nil {
		var (
			responseOut *gollam.Response
			errOut      error
		)
		return responseOut, errOut
	}
	return mock.GenerateContentFunc(ctx, input...)
}

// GenerateContentCalls gets all the calls that were made to GenerateContent.
// Check the length with:
//
//	len(mockedSession.GenerateContentCalls())
func (mock *SessionMock) GenerateContentCalls() []struct {
	Ctx   context.Context
	Input []gollam.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollam.Input
	}
	mock.lockGenerateContent.RLock()
	calls = mock.calls.GenerateContent
	mock.lockGenerateContent.RUnlock()
	return calls
}

// GenerateStream calls GenerateStreamFunc.
func (mock *SessionMock) GenerateStream(ctx context.Context, input ...gollam.Input) (<-chan *gollam.Response, error) {
	callInfo := struct {
		Ctx   context.Context
		Input []gollam.Input
	}{
		Ctx:   ctx,
		Input: input,
	}
	mock.lockGenerateStream.Lock()
	mock.calls.GenerateStream = append(mock.calls.GenerateStream, callInfo)
	mock.lockGenerateStream.Unlock()
	if mock.GenerateStreamFunc == nil {
		var (
			responseChOut <-chan *gollam.Response
			errOut        error
		)
		return responseChOut, errOut
	}
	return mock.GenerateStreamFunc(ctx, input...)
}

// GenerateStreamCalls gets all the calls that were made to GenerateStream.
// Check the length with:
//
//	len(mockedSession.GenerateStreamCalls())
func (mock *SessionMock) GenerateStreamCalls() []struct {
	Ctx   context.Context
	Input []gollam.Input
} {
	var calls []struct {
		Ctx   context.Context
		Input []gollam.Input
	}
	mock.lockGenerateStream.RLock()
	calls = mock.calls.GenerateStream
	mock.lockGenerateStream.RUnlock()
	return calls
}

// History calls HistoryFunc.
func (mock *SessionMock) History() *gollam.History {
	callInfo := struct {
	}{}
	mock.lockHistory.Lock()
	mock.calls.History = append(mock.calls.History, callInfo)
	mock.lockHistory.Unlock()
	if mock.HistoryFunc == nil {
		var (
			historyOut *gollam.History
		)
		return historyOut
	}
	return mock.HistoryFunc()
}

// HistoryCalls gets all the calls that were made to History.
// Check the length with:
//
//	len(mockedSession.HistoryCalls())
func (mock *SessionMock) HistoryCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHistory.RLock()
	calls = mock.calls.History
	mock.lockHistory.RUnlock()
	return calls
}

// ToolMock is a mock implementation of gollam.Tool.
//
//	func TestSomethingThatUsesTool(t *testing.T) {
//
//		// make and configure a mocked gollam.Tool
//		mockedTool := &ToolMock{
//			RunFunc: func(ctx context.Context, args map[string]any) (map[string]any, error) {
//				panic("mock out the Run method")
//			},
//			SpecFunc: func() gollam.ToolSpec {
//				panic("mock out the Spec method")
//			},
//		}
//
//		// use mockedTool in code that requires gollam.Tool
//		// and then make assertions.
//
//	}
type ToolMock struct {
	// RunFunc mocks the Run method.
	RunFunc func(ctx context.Context, args map[string]any) (map[string]any, error)

	// SpecFunc mocks the Spec method.
	SpecFunc func() gollam.ToolSpec

	// calls tracks calls to the methods.
	calls struct {
		// Run holds details about calls to the Run method.
		Run []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args map[string]any
		}
		// Spec holds details about calls to the Spec method.
		Spec []struct {
		}
	}
	lockRun  sync.RWMutex
	lockSpec sync.RWMutex
}

// Run calls RunFunc.
func (mock *ToolMock) Run(ctx context.Context, args map[string]any) (map[string]any, error) {
	callInfo := struct {
		Ctx  context.Context
		Args map[string]any
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	if mock.RunFunc == nil {
		var (
			stringToVOut map[string]any
			errOut       error
		)
		return stringToVOut, errOut
	}
	return mock.RunFunc(ctx, args)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedTool.RunCalls())
func (mock *ToolMock) RunCalls() []struct {
	Ctx  context.Context
	Args map[string]any
} {
	var calls []struct {
		Ctx  context.Context
		Args map[string]any
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// Spec calls SpecFunc.
func (mock *ToolMock) Spec() gollam.ToolSpec {
	callInfo := struct {
	}{}
	mock.lockSpec.Lock()
	mock.calls.Spec = append(mock.calls.Spec, callInfo)
	mock.lockSpec.Unlock()
	if mock.SpecFunc == nil {
		var (
			toolSpecOut gollam.ToolSpec
		)
		return toolSpecOut
	}
	return mock.SpecFunc()
}

// SpecCalls gets all the calls that were made to Spec.
// Check the length with:
//
//	len(mockedTool.SpecCalls())
func (mock *ToolMock) SpecCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSpec.RLock()
	calls = mock.calls.Spec
	mock.lockSpec.RUnlock()
	return calls
}
